<#@ template language="C#" linePragmas="false" debug="false" hostspecific="false" visibility="internal" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.CodeAnalysis" #>

#pragma warning disable CS0169, CS0649

<# if(this.Options.IsNamespaceSpecified) { #>
namespace <#= this.Options.Namespace #>
{
<# } #>
	readonly partial struct <#= this.Options.Name #> 
	{
		public enum Case 
		{
			<#= string.Join(", ", this.Options.Methods.Select(method => method.Name)) #>
		}
		struct __Implement
		{
			[global::System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Explicit)]
			public struct Union 
			{
<# foreach(var method in this.Options.Methods) { #>
<# var referenceLeft = this.Options.ReferenceTypeCount; #>
				public struct __<#= method.Name #>
				{
<# foreach(var parameter in method.Parameters.Where(p => p.Type.IsReferenceType)) { #>
<# referenceLeft--; #>
<# if(parameter.Type is ITypeParameterSymbol) { #>
					public object <#= parameter.Name #>;
<# } else { #>
					public <#= Helper.FullNameOf(parameter.Type) #> <#= parameter.Name #>;
<# } #>
<# } #>
<# for(var index = 0; index < referenceLeft; ++index) { #>
					object __dummy_<#= index #>;
<# } #>
<# foreach(var parameter in method.Parameters.Where(p => p.Type is not ITypeParameterSymbol && p.Type.IsUnmanagedType)) { #>
					public <#= Helper.FullNameOf(parameter.Type) #> <#= parameter.Name #>;
<# } #>
				}
<# } #>

<# foreach(var method in this.Options.Methods) { #>
				[global::System.Runtime.InteropServices.FieldOffset(0)]
				public __<#= method.Name #> <#= method.Name #>;
<# } #>
			}

			public struct Serial
			{
<# foreach(var (type, count) in this.Options.SerialTypes) { #>
<# for(var i = 0; i < count; ++i) { #>
				public <#= Helper.FullNameOf(type) #> <#= Helper.EscapedFullNameOf(type) #>_<#= i #>;
<# } #>
<# } #>
			}

			public Case type;
			public Union union;
			public Serial serial;

			public <#= this.Options.Identifier #> As() => global::System.Runtime.CompilerServices.Unsafe.As<__Implement, <#= this.Options.Identifier #>>(ref this);
		}

<# foreach(var method in this.Options.Methods) { #>
		public static partial <#= this.Options.Identifier #> <#= method.Name #>(<#= Helper.ParamsOf(method) #>) 
		{
			var impl = default(__Implement);
			impl.type = Case.<#= method.Name #>;

<# foreach(var parameter in method.Parameters) { #>
<# if(Helper.IsSerialType(parameter.Type)) { #>
<# var index = method.Parameters.Take(parameter.Ordinal).Count(p => Helper.SymbolEquals(p.Type, parameter.Type)); #>
			impl.serial.<#= Helper.FullNameOf(parameter.Type) #>_<#= index #> = <#= parameter.Name #>;
<# } else { #>
			impl.union.<#= method.Name #>.<#= parameter.Name #> = <#= parameter.Name #>;
<# } #>
<# } #>

			return impl.As();
		}

		[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
		public static bool <#= method.Name #>(<#= this.Options.DeconstructMethodParamsOf(method) #>) 
		{
			if (__self.Type == Case.<#= method.Name #>)
			{
<# foreach(var parameter in method.Parameters) { #>
<# var fullName = Helper.FullNameOf(parameter.Type); #>
<# if(Helper.IsSerialType(parameter.Type)) { #>
<# var index = method.Parameters.Take(parameter.Ordinal).Count(p => Helper.SymbolEquals(p.Type, parameter.Type)); #>
				<#= parameter.Name #> = __self.__implement.serial.<#= fullName #>_<#= index #>;
<# } else if(parameter.Type is ITypeParameterSymbol) { #>
				<#= parameter.Name #> = (<#= fullName #>)__self.__implement.union.<#= method.Name #>.<#= parameter.Name #>;
<# } else { #>
				<#= parameter.Name #> = __self.__implement.union.<#= method.Name #>.<#= parameter.Name #>;
<# } #>
<# } #>
				return true;
			}

<# foreach(var parameter in method.Parameters) { #>
			<#= parameter.Name #> = default;
<# } #>
			return false;
		}
<# } #>

		readonly __Implement __implement;
		public Case Type => this.__implement.type;
	}
<# if(this.Options.IsNamespaceSpecified) { #>
}
<# } #>

#pragma warning restore CS0169, CS0649